<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>BCPy2000: Developing_Python_for_Windows</title>
<link type="text/css" rel="stylesheet" href="styles/gears/style.css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<div class="header"><span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span><h1>Developing Python for Windows</h1></div><div class="content"><p>At the "Python in Neuroscience" workshop at CNS 2009 in Berlin, the round-table discussion got onto the subject of Windows. Nobody liked the idea of supporting it, yet a significant segment of the neuroscience community is tied to it for various reasons. Now, I have no love for Windows or proprietary software of any kind, but somehow I found myself saying </p><ul><li>that Windows shouldn't be excluded as a platform for open-source development;</li><li>that we should package our software in a way that will encourage people to come to Python, and to build upon what we've done, without getting them bogged down in installation issues;</li><li>that supporting Python for Windows can be done without any closed-source tools, except the OS itself;</li><li>and that while the lack of proper package management may be annoying, supporting Windows is not as bad as most people present seemed to think.</li></ul><p>The last claim in particular prompted <a class="url http outside" href="http://www.davison.webfactional.com/">Andrew Davison</a> to ask me to write a HOWTO. So here it is. There is also some <a class="url http outside" href="http://bci2000.org/downloads/BCPy2000/dist/PythonWin32Example.zip">example code</a> to go with it.</p><div class="toc"><h2>Contents</h2><ol><li><a href="#Heading1">Requirements for Building Bound C/C++ Code</a><ol><li><a href="#Heading2">MinGW</a></li><li><a href="#Heading3">SWIG</a></li></ol></li><li><a href="#Heading4">Business as Usual</a></li><li><a href="#Heading5">Binary Installers</a></li><li><a href="#Heading6">What about 64-bit Windows?</a></li><li><a href="#Heading7">Package Dependencies</a><ol><li><a href="#Heading8">The "Easy" Way</a></li><li><a href="#Heading9">The Brute-Force Approach</a></li><li><a href="#Heading10">The Hard-Cheese Shop</a></li><li><a href="#Heading11">Third-Party Distros</a></li></ol></li><li><a href="#Heading12">Links</a></li></ol></div><hr /><h1 id="Heading1">Requirements for Building Bound C/C++ Code</h1><p>Among developers of packages that contain C/C++ code in addition to plain Python, one of the first things that deters people from supporting Windows is the compiler. For some incomprehensible reason, the official Python-for-Windows releases were built using a proprietary compiler (some particular version of Microsoft Visual Studio) and it was initially hard to build extensions using anything else. Even using a different version of MVS could be tricky.</p><p>Luckily, support for other compilers, and specifically <code>gcc</code>, has caught up to a large extent. This means that it is possible to develop Python extensions for Windows using only free, open-source tools, and with only relatively minor changes to one's development scripts.</p><p>As of version 2.4.4 (and maybe earlier---I haven't checked) Python's built-in <code>distutils</code> contain support for gcc via <a class="url http outside" href="http://mingw.org">MinGW</a>, which stands for "Minimalist GNU for Windows". This is available in two ways: as part of <a class="url http outside" href="http://cygwin.com">Cygwin</a>'s gcc distribution, or as a relatively slim (hence "minimalist") distribution of its own.</p><p>The biggest favour one can do oneself, as a cross-platform developer forced to include Windows in one's repertoire, is to get a decent Cygwin installation up and running. With an X11 server starting automatically on login, and bash shells running in four tabs of mrxvt, a lot of the pain goes away---sometimes I can almost forget I'm even on Windows. However, for the purposes of this HOWTO, I'll just assume an installation of MinGW (which can, incidentally, be installed in parallel with Cygwin without any trouble). I'll also assume we're going to use <a class="url http outside" href="http://www.swig.org">SWIG</a> for binding Python and C/C++ (simply because I have no experience yet with the groovier universe of Cython, PyBindGen et al.)</p><h2 id="Heading2">MinGW</h2><p>I simply used the web installer <code>MinGW-5.1.4.exe</code> from <a class="url http outside" href="http://sourceforge.net/projects/mingw/files/Automated%20MinGW%20Installer/MinGW%205.1.4/MinGW-5.1.4.exe/download">here</a>. This executable wizardtastically automates the downloading, unpacking and installation of MinGW's various components from compressed tarballs.</p><p>Let's assume that the directory it creates for the MinGW installation is called <code>C:\MinGW</code>. That directory's <code>bin</code> subdirectory will need to be on Windows' executable path. This can be done per-DOS-shell-session with this command </p><pre class="real">set PATH=C:\MinGW\bin;%PATH%
</pre><p>or more permanently via  Start Menu -&gt; Control Panel -&gt; System -&gt; Advanced -&gt; Environmental Variables, where you then edit the system variable <code>Path</code> (a semicolon-delimited list of Windows paths) to include <code>C:\MinGW\bin;</code></p><h2 id="Heading3">SWIG</h2><p>For binary extensions that need swigging, the Windows implementation of SWIG is even easier to obtain. I downloaded the binary distribution <code>swigwin-1.3.39.zip</code> from <a class="url http outside" href="http://sourceforge.net/projects/swig/files/swigwin/swigwin-1.3.39/swigwin-1.3.39.zip/download">here</a>, unzipped it, and then made sure that the resulting top-level directory (containing <code>swig.exe</code>) was on the executable path, using one or other of the methods above.</p><p>The batch file in the template code archive assumes that this directory is <code>C:\swigwin</code> .</p><hr /><h1 id="Heading4">Business as Usual</h1><p>Now we're ready to use distutils, based on the <code>setup.py</code> script you've written for your package. From an IPython prompt this is easy, with <code>run setup.py ...</code>. Alternatively we can do it from the DOS command line, or in a Windows <code>.bat</code> or <code>.cmd</code> file---then, as on other platforms, the path to the Python executable you run determines which Python installation you're operating in. I'm going to assume <code>C:\Python25</code> in the examples below. In all cases, the only unusual thing we need to remember is to select the mingw32 compiler with the <code>-c</code> switch following the <code>build</code> subcommand.</p><p>So you could in theory build and install a mixed package from source with </p><pre class="real">C:\Python25\python.exe setup.py build -cmingw32 install
</pre><p>Before you do that, though, read the next section.</p><hr /><h1 id="Heading5">Binary Installers</h1><p>A Windows binary installer is nice for deployment to the unthinking end-user. It automatically detects registry entries for installed Python distributions, and filters them for compatibility with the payload. Typically there will only be one hit, but if there are more then the user will be offered a choice of install locations. The installer installs all the package files in a wizardly way, and can also execute post-install Python scripts.</p><p>Installing this way also has one distinct advantage, even for the Windows-phobic developer who can scarcely stomach the idea of clicking through a wizard. We all bemoan the lack of decent package management under Windows, but at least one simple deficiency is remedied this way, namely sensible uninstallation. The binary installer creates and registers a corresponding uninstaller---while there is no resolution of dependencies, at least the clean removal of the installed files, package directories and <code>.egg-info</code> is then possible via  Start Menu -&gt; Control Panel -&gt; Add Or Remove Programs, where you will find all your Python package installations listed under "Python", sorted by Python-version, then package name and version.</p><p>Making a Windows binary installer is easy: for pure-Python packages, you can just say </p><pre class="real">C:\Python25\python.exe setup.py bdist_wininst
</pre><p>whereas mixed packages, in a way analogous to the <code>install</code> subcommand, can be built and packaged with </p><pre class="real">C:\Python25\python.exe setup.py build -cmingw32 bdist_wininst
</pre><p>where the <code>bdist_wininst</code> subcommand understands many of the same flags as <code>install</code> (for example, <code>--skip-build</code> to skip extensions and produce an installer for only the pure-Python subset).</p><p>As usual the product will end up in the automatically-created <code>dist</code> directory, and the filename will encode your package's name and version, the platform (win32) and (if necessary) the Python version. Its file extension will be <code>.exe</code>, allowing it to be launched by double-click, or by the DOS command <code>start</code>. It can also be used as an input to <code>easy_install.py</code> (or <code>easy_install.exe</code>) in which case an <code>.egg</code> is extracted from it, and no uninstaller is created.</p><p>Some further tricks include: </p><ul><li>adding your logo to the installer, with <br /> <code>bdist_wininst --bitmap=MyLogo.bmp</code> ;</li><li>adding a post-install script with <br /> <code>bdist_wininst --install-script=MyScript.py</code> (provided you also remember to pack the script itself, by including <br /> <code>scripts=['MyScript.py',],</code> in the call to <code>setup</code>);</li><li>building an <code>.msi</code> file instead of an executable, using <code>bdist_msi</code> instead of <code>bdist_wininst</code>.</li></ul><p>More information about building binary distributions can be obtained at <a class="url http outside" href="http://docs.python.org/distutils/builtdist.html">http://docs.python.org/distutils/builtdist.html</a> .</p><hr /><h1 id="Heading6">What about 64-bit Windows?</h1><p>I'm unsure as to support for 64-bit architectures. Under Python 2.6+, it appears from <a class="url http outside" href="http://docs.python.org/distutils/builtdist.html#cross-compiling-on-windows">this official document</a> that you can cross-compile, for example using <code>build --plat-name=win-amd64</code> provided your compiler supports it. <a class="url http outside" href="http://mingw.org/wiki/MinGW">This blurb</a> on mingw.org suggests to me that distutils' reference to "mingw32" might simply be a legacy misnomer: the MinGW project aims to support both 32-bit and 64-bit platforms in one unified distro, despite being formerly <em>named</em> "mingw32". On the other hand, there appears to exist a somewhat differently-named (possibly separate?) project called <a class="url http outside" href="http://sourceforge.net/projects/mingw-w64/">MinGW-W64</a>, so who knows exactly what's going on there. At any rate, for me, cross-compiling for amd64 under {i686, WinXP, Python 2.6.2, MinGW 5.1.4} has so far failed with a distutils error---it seems distutils' MinGW glue has simply not been updated, as indeed its continued use of the legacy name would also suggest.</p><p><a class="url http outside" href="http://docs.python.org/distutils/apiref.html#module-distutils.command.bdist_msi">Here</a> it says that building a <code>bdist_msi</code> instead of a <code>bdist_wininst</code> allows "better support for Win64 platforms" at installation time, although I have no idea what this means.</p><hr /><h1 id="Heading7">Package Dependencies</h1><p>This is where things are harder on Windows. It's not only the lack of a general package-manager---after all, for all Python and Python-wrapped things, <code>easy_install</code> from the <code>setuptools</code> package could fill this role. The problem also lies in the tendency of Windows users to be unfamiliar with that way of working. Even the so-called <code>easy_install</code> is <em>only</em> easy once your users are comfortable working from a command-line and have spent some time understanding what a package-manager actually does. If you are reading this, there is a good chance that you have already forgotten what a learning curve that was. But we neither want our prospective users to, nor expect them to want to, get bogged down with bootstrapping. Within 5 minutes of finding our website and deciding to download whatever wonderful Python tools we've developed, they should be trying out and extending our carefully-crafted example scripts.</p><p>Here are a few different strategies, none of them quite perfect, that I can think of to tackle this problem during deployment to the end-user:</p><h2 id="Heading8">The "Easy" Way</h2><p>One way would be to find a painless way of introducing users to, and guiding them through, <code>easy_install</code>. Perhaps there are already graphical front-ends available, such as the (as yet unexplored by me) <a class="url http outside" href="http://sourceforge.net/projects/pythonpkgmgr/">Python Package Manager</a>? This wouldn't need to be much more than something that the user can double-click to launch and then type the desired package name into a box.</p><p>As a developer, if your <code>setup.py</code> imports <code>setuptools</code> and your <code>setup</code> call then uses the <code>install_requires</code> option, <code>easy_install</code> will handle the dependencies when it installs your package for the user.</p><p>One downside of <code>easy_install</code> is that we lose the ability to uninstall anything easily.</p><h2 id="Heading9">The Brute-Force Approach</h2><p>Assuming your package's dependencies are open-source, there's nothing stopping you redistributing <em>all</em> of them together with your package, starting with Python itself.</p><p>Take a look at the <code>python25-installers-*.zip</code> file on <a class="local canonical" title="Download" href="Download.html">the BCPy2000 download page</a> to see how I decided to do it. Note that you cannot download the binary installer for my package on its own: on unzipping the archive, the user is faced with a whole folder full of Windows binary installers, their filenames prefixed with numbers so that they are in the correct dependency order. Users entirely new to Python can just double-click on <code>INSTALL_ALL.bat</code>, which will launch all of them in order. All they have to do then is click through each wizard, which takes about 2 minutes in total. More-experienced users with a pre-existing Python installation will hopefully be able to look at the list and immediately get some sort of overview of what they need to launch and what not, perhaps aided by <a class="local canonical" title="Python_Packages" href="Python_Packages.html">additional documentation</a>.</p><p>Advantages of this "live-CD"-like approach include the uninstallers that get registered by each of the installers, the flexbility of being able to target total newbies as well as slightly-more-experienced users, and the ability to "freeze" the entire distribution at a set of dependency versions that you know will work together. Users can also be sure of downloading everything they need in one go---with a large number of dependencies, the likelihood that <em>somebody's</em> webserver is down at any one time is quite high. Disadvantages include the exploding bandwidth and storage requirements, and the developer-side tedium of keeping track of all the dependencies by hand, not to mention the work involved in updating the entire distro.</p><h2 id="Heading10">The Hard-Cheese Shop</h2><p>A third approach that comes to mind is to include, in your package, comprehensive Python code for attempting to import and check the versions of all the package's dependencies. This code is run every time the package is newly imported, and could possibly also be invoked by the post-install script of your binary installer. If any dependencies are missing or too old, the package simply refuses to run, printing a message explaining exactly which dependencies are not met, and where to download them. You could include instructions for how to install and use <code>easy_install</code> if you want to take users down that path.</p><p>This has the disadvantage of putting more of a burden on the user, although one could perhaps take it one step further (and hybridize it with the "easy" way, above) by including <code>ez_setup.py</code> in the package and calling it automatically on such occasions.</p><p>Relative to the Brute-Force approach, this has the advantage that you only have to manage and distribute your own code. There is the disadvantage of having to write the diagnostic routines and user-friendly messages yourself. (True to Python's cultural heritage, you could perhaps make this task more enjoyable by making the messages alternately rude and polite.)</p><h2 id="Heading11">Third-Party Distros</h2><p>Combining some of the best characteristics of the "Easy" way and the Brute-Force approach are various third-party distros for Windows. All of these include NumPy, SciPy, matplotlib and IPython out of the box:</p><ul><li><a class="url http outside" href="http://portablepython.com">Portable Python</a> includes the core scientific tools mentioned above, and will create Python distributions that can be run from external media, and/or installed, managed and run by people who do not have Administrator privileges. It would be potentially good for creating massive Brute-Force-style distributions (zipped-up, runnable, portable distributions, with everything already installed).</li><li>The <a class="url http outside" href="http://www.enthought.com/products/epd.php">Enthought Python Distribution</a> is a well-maintained scientific distro, going way beyond the core tools and available for multiple platforms including Windows.</li><li><a class="url http outside" href="http://pythonxy.com">Python(x,y)</a> is possibly the most promising of these. It is also a big distro, installing many additional tools including the Enthought Tool Suite, setuptools, MinGW, SWIG, and a lot of other useful things, right out of the box. The setup program is a one-stop installer for everything, and incremental updaters can also be downloaded from the project's website. It's not clear to me yet what you do if you have <em>additional</em> dependencies not included by Python(x,y)â€”perhaps you're back to relying on <code>easy_install</code>.</li></ul><hr /><h1 id="Heading12">Links</h1><ul><li><a class="url http outside" href="http://cygwin.com">Cygwin</a>, the only reason I am still sane;</li><li><a class="url http outside" href="http://mingw.org">MinGW</a>, a slimline <code>gcc</code>/<code>g++</code> distribution for Windows-native compilation;</li><li><a class="url http outside" href="http://www.swig.org">SWIG</a>, one way of binding C/C++ to Python;</li><li><a class="url http outside" href="http://docs.python.org/library/distutils.html">distutils</a>, Python's builtin mechanism for making and installing packages; includes documentation on:<ul><li><a class="url http outside" href="http://docs.python.org/distutils/setupscript.html">writing the setup.py script</a>;</li><li><a class="url http outside" href="http://docs.python.org/distutils/builtdist.html">building binary installers</a>;</li></ul></li><li><a class="url http outside" href="http://peak.telecommunity.com/DevCenter/setuptools">setuptools</a>, a thirdparty package that enhances <code>distutils</code> and can act like a Python package manager;</li><li><a class="url http outside" href="http://ianbicking.org/docs/setuptools-presentation/">Ian Bicking's presentation</a> about <code>setuptools</code>;</li><li><a class="url http outside" href="http://bci2000.org/downloads/BCPy2000/dist/PythonWin32Example.zip">some template code</a> I wrote for trying out this HOWTO under 32-bit Windows.</li></ul><hr /></div><div class="footer"><hr /> <span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span> <span class="edit"></span> <span class="time"><span class="time"><br /> Last edited 2009-09-01 15:31 UTC by musi.kyb.local <a class="diff">(diff)</a></span></span></div></body></html>